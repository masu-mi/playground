// Code generated by golex. DO NOT EDIT.

package main

import (
	"flag"
	"fmt"
)

var (
	c    byte
	src  string
	in   []byte
	un   []byte
	mark int
)

func lex() (s string) {

yystate0:
	yyrule := -1
	_ = yyrule
	in = in[:0]
	mark = -1

	goto yystart1

yyAction:
	switch yyrule {
	case 1:
		goto yyrule1
	case 2:
		goto yyrule2
	}
yystate1:
	next()
yystart1:
	switch {
	default:
		goto yyabort
	case c == '\x00':
		goto yystate2
	case c == 'a':
		goto yystate3
	}

yystate2:
	next()
	yyrule = 1
	fmt.Printf("\tstate accepts: %q\n", in)
	mark = len(in)
	goto yyrule1

yystate3:
	next()
	yyrule = 2
	fmt.Printf("\tstate accepts: %q\n", in)
	mark = len(in)
	switch {
	default:
		goto yyrule2
	case c == 'z':
		goto yystate5
	case c >= 'b' && c <= 'd':
		goto yystate4
	}

yystate4:
	next()
	switch {
	default:
		goto yyabort
	case c == 'z':
		goto yystate5
	case c >= 'b' && c <= 'd':
		goto yystate4
	}

yystate5:
	next()
	yyrule = 2
	fmt.Printf("\tstate accepts: %q\n", in)
	mark = len(in)
	switch {
	default:
		goto yyrule2
	case c == 'z':
		goto yystate7
	case c >= 'e' && c <= 'g':
		goto yystate6
	}

yystate6:
	next()
	switch {
	default:
		goto yyabort
	case c == 'z':
		goto yystate7
	case c >= 'e' && c <= 'g':
		goto yystate6
	}

yystate7:
	next()
	yyrule = 2
	fmt.Printf("\tstate accepts: %q\n", in)
	mark = len(in)
	goto yyrule2

yyrule1: // \0
	{

		return "EOF"
	}
yyrule2: // a([bcd]*z([efg]*z)?)?
	if true { // avoid go vet determining the below panic will not be reached

		return fmt.Sprintf("match(%q)", in)
	}
	panic("unreachable")

yyabort: // no lexem recognized
	//
	// silence unused label errors for build and satisfy go vet reachability analysis
	//
	{
		if false {
			goto yyabort
		}
		if false {
			goto yystate0
		}
		if false {
			goto yystate1
		}
	}

	if mark >= 0 {
		if len(in) > mark {
			unget(c)
			for i := len(in) - 1; i >= mark; i-- {
				unget(in[i])
			}
			next()
		}
		in = in[:mark]
		goto yyAction // Hook: Execute the semantic action of the last matched rule.
	}

	switch n := len(in); n {
	case 0: // [] z
		s = fmt.Sprintf("%q", c)
		next()
	case 1: // [x] z
		s = fmt.Sprintf("%q", in[0])
	default: // [x, y, ...], z
		s = fmt.Sprintf("%q", in[0])
		unget(c) // z
		for i := n - 1; i > 1; i-- {
			unget(in[i]) // ...
		}
		c = in[1] // y
	}
	return s
}

func next() {
	if len(un) != 0 {
		c = un[len(un)-1]
		un = un[:len(un)-1]
		return
	}

	in = append(in, c)
	if len(src) == 0 {
		c = 0
		return
	}

	c = src[0]
	fmt.Printf("\tnext: %q\n", c)
	src = src[1:]
}

func unget(b byte) {
	un = append(un, b)
}

func main() {
	flag.Parse()
	if flag.NArg() > 0 {
		src = flag.Arg(0)
	}
	next()
	for {
		s := lex()
		fmt.Println(s)
		if s == "EOF" {
			break
		}
	}
}
